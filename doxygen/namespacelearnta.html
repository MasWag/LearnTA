<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LearnTA: learnta Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LearnTA
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">learnta Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1ExperimentRunner.html">ExperimentRunner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1OtaJsonParser.html">OtaJsonParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parser of one clock TAs in the json format of <a href="https://github.com/Leslieaj/OTALearning">https://github.com/Leslieaj/OTALearning</a>.  <a href="classlearnta_1_1OtaJsonParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1BackwardRegionalElementaryLanguage.html">BackwardRegionalElementaryLanguage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A back regional elementary language.  <a href="classlearnta_1_1BackwardRegionalElementaryLanguage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlearnta_1_1Automaton.html">Automaton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An automaton.  <a href="structlearnta_1_1Automaton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlearnta_1_1Constraint.html">Constraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constraint in a guard of transitions.  <a href="structlearnta_1_1Constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1ConstraintMaker.html">ConstraintMaker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1ElementaryLanguage.html">ElementaryLanguage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An elementary language.  <a href="classlearnta_1_1ElementaryLanguage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1EquivalenceOracleChain.html">EquivalenceOracleChain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A chain of the equivalence oracles.  <a href="classlearnta_1_1EquivalenceOracleChain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1EquivalenceOracle.html">EquivalenceOracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the equivalence oracle.  <a href="classlearnta_1_1EquivalenceOracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1EquivalenceOracleByRandomTest.html">EquivalenceOracleByRandomTest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The equivalence oracle by random test.  <a href="classlearnta_1_1EquivalenceOracleByRandomTest.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1EquivalenceOracleByTest.html">EquivalenceOracleByTest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the equivalence oracle.  <a href="classlearnta_1_1EquivalenceOracleByTest.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1EquivalenceOracleMemo.html">EquivalenceOracleMemo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper of an equivalence oracle to cache the queries.  <a href="classlearnta_1_1EquivalenceOracleMemo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1ExternalTransitionMaker.html">ExternalTransitionMaker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to make a transition from P to ext(P)  <a href="classlearnta_1_1ExternalTransitionMaker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1ForwardRegionalElementaryLanguage.html">ForwardRegionalElementaryLanguage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward regional elementary language.  <a href="classlearnta_1_1ForwardRegionalElementaryLanguage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1FractionalOrder.html">FractionalOrder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order on the fractional part of the variables.  <a href="classlearnta_1_1FractionalOrder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1ImpreciseClockHandler.html">ImpreciseClockHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relax guards to handle imprecise clock variables.  <a href="classlearnta_1_1ImpreciseClockHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1InternalTransitionMaker.html">InternalTransitionMaker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to make a transition from P to P.  <a href="classlearnta_1_1InternalTransitionMaker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1JuxtaposedZone.html">JuxtaposedZone</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A zone constructed by juxtaposing two zones with or without shared variables.  <a href="classlearnta_1_1JuxtaposedZone.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1JuxtaposedZoneSet.html">JuxtaposedZoneSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1Learner.html">Learner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The deterministic timed automata learner.  <a href="classlearnta_1_1Learner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1MembershipOracle.html">MembershipOracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of a membership oracle.  <a href="classlearnta_1_1MembershipOracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1SULMembershipOracle.html">SULMembershipOracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Membership oracle defined by an <a class="el" href="classlearnta_1_1SUL.html" title="Interface of the system under learning.">SUL</a>.  <a href="classlearnta_1_1SULMembershipOracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1MembershipOracleCache.html">MembershipOracleCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper of a membership oracle to cache the result.  <a href="classlearnta_1_1MembershipOracleCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1NeighborConditions.html">NeighborConditions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementary language with its neighbor conditions.  <a href="classlearnta_1_1NeighborConditions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1ObservationTable.html">ObservationTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed observation table.  <a href="classlearnta_1_1ObservationTable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1RecognizableLanguage.html">RecognizableLanguage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recognizable timed language in [MP04].  <a href="classlearnta_1_1RecognizableLanguage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1RenamingRelation.html">RenamingRelation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1SingleMorphism.html">SingleMorphism</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Morphism from an external elementary language to an internal one.  <a href="classlearnta_1_1SingleMorphism.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1SUL.html">SUL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the system under learning.  <a href="classlearnta_1_1SUL.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1SymbolicMembershipOracle.html">SymbolicMembershipOracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The oracle to answer symbolic membership queries.  <a href="classlearnta_1_1SymbolicMembershipOracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1SymbolicRun.html">SymbolicRun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run of a zone automaton.  <a href="classlearnta_1_1SymbolicRun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1ComplementTimedAutomataEquivalenceOracle.html">ComplementTimedAutomataEquivalenceOracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalence oracle with a timed automaton recognizing the complement of the target language.  <a href="classlearnta_1_1ComplementTimedAutomataEquivalenceOracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlearnta_1_1TAState.html">TAState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A state of timed automata.  <a href="structlearnta_1_1TAState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlearnta_1_1TATransition.html">TATransition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A state of timed automata.  <a href="structlearnta_1_1TATransition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlearnta_1_1TimedAutomaton.html">TimedAutomaton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A timed automaton.  <a href="structlearnta_1_1TimedAutomaton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1TimedAutomatonRunner.html">TimedAutomatonRunner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to execute a timed automaton.  <a href="classlearnta_1_1TimedAutomatonRunner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1TimedCondition.html">TimedCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A timed condition, a finite conjunction of inequalities of the form \(\tau_{i} + \tau_{i + 1} \dots \tau_{j} \bowtie c\), where \({\bowtie} \in \{&gt;,\ge,\le,&lt;\}\) and \(c \in \mathbb{N} \).  <a href="classlearnta_1_1TimedCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1TimedConditionSet.html">TimedConditionSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of timed conditions to represent non-convex constraints.  <a href="classlearnta_1_1TimedConditionSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlearnta_1_1TimedWord.html">TimedWord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A timed word.  <a href="classlearnta_1_1TimedWord.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlearnta_1_1Zone.html">Zone</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a zone with DBM.  <a href="structlearnta_1_1Zone.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlearnta_1_1ZoneAutomaton.html">ZoneAutomaton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structlearnta_1_1Zone.html" title="Implementation of a zone with DBM.">Zone</a> automaton.  <a href="structlearnta_1_1ZoneAutomaton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlearnta_1_1ZAState.html">ZAState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A state of a zone automaton.  <a href="structlearnta_1_1ZAState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlearnta_1_1ManualEqTester.html">ManualEqTester</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8c694284cbf71a844f2c027925c567b6"><td class="memItemLeft" align="right" valign="top"><a id="a8c694284cbf71a844f2c027925c567b6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Bounds</b> = std::pair&lt; double, bool &gt;</td></tr>
<tr class="separator:a8c694284cbf71a844f2c027925c567b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1c4dd946f9a3812246f91e7ad2b0f0"><td class="memItemLeft" align="right" valign="top"><a id="a0b1c4dd946f9a3812246f91e7ad2b0f0"></a>
typedef char&#160;</td><td class="memItemRight" valign="bottom"><b>Alphabet</b></td></tr>
<tr class="separator:a0b1c4dd946f9a3812246f91e7ad2b0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c676024c1f3e078aafde9d408580db"><td class="memItemLeft" align="right" valign="top"><a id="a45c676024c1f3e078aafde9d408580db"></a>
typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>ClockVariables</b></td></tr>
<tr class="separator:a45c676024c1f3e078aafde9d408580db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64aef4c8c6f3d811b91d4e3cf3a0f806"><td class="memItemLeft" align="right" valign="top"><a id="a64aef4c8c6f3d811b91d4e3cf3a0f806"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IntBounds</b> = std::pair&lt; int, bool &gt;</td></tr>
<tr class="separator:a64aef4c8c6f3d811b91d4e3cf3a0f806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db5f6c1ead39b41221602f91e7fee11"><td class="memItemLeft" align="right" valign="top"><a id="a8db5f6c1ead39b41221602f91e7fee11"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>RenamingGraph</b> = std::pair&lt; std::vector&lt; std::vector&lt; std::size_t &gt; &gt;, std::vector&lt; std::vector&lt; std::size_t &gt; &gt;&gt;</td></tr>
<tr class="separator:a8db5f6c1ead39b41221602f91e7fee11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a66b60facb93a4fb16c606afa351cc170"><td class="memItemLeft" align="right" valign="top"><a id="a66b60facb93a4fb16c606afa351cc170"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#a66b60facb93a4fb16c606afa351cc170">Order</a> { <b>LT</b>
, <b>EQ</b>
, <b>GT</b>
 }</td></tr>
<tr class="memdesc:a66b60facb93a4fb16c606afa351cc170"><td class="mdescLeft">&#160;</td><td class="mdescRight">The return values of comparison of two values. Similar to strcmp. <br /></td></tr>
<tr class="separator:a66b60facb93a4fb16c606afa351cc170"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac75df99c800eea7d89ca49e1a34af62e"><td class="memItemLeft" align="right" valign="top"><a id="ac75df99c800eea7d89ca49e1a34af62e"></a>
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classlearnta_1_1BackwardRegionalElementaryLanguage.html">learnta::BackwardRegionalElementaryLanguage</a> &amp;lang)</td></tr>
<tr class="separator:ac75df99c800eea7d89ca49e1a34af62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29632a2fb18441ee1b578e68bbf93ddb"><td class="memItemLeft" align="right" valign="top"><a id="a29632a2fb18441ee1b578e68bbf93ddb"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>hash_value</b> (<a class="el" href="classlearnta_1_1BackwardRegionalElementaryLanguage.html">learnta::BackwardRegionalElementaryLanguage</a> const &amp;lang)</td></tr>
<tr class="separator:a29632a2fb18441ee1b578e68bbf93ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe912986ca00e2a0c635b515f92694be"><td class="memItemLeft" align="right" valign="top"><a id="abe912986ca00e2a0c635b515f92694be"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#abe912986ca00e2a0c635b515f92694be">isPoint</a> (const Bounds &amp;upperBound, const Bounds &amp;lowerBound)</td></tr>
<tr class="memdesc:abe912986ca00e2a0c635b515f92694be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the upper and lower bounds define a point. <br /></td></tr>
<tr class="separator:abe912986ca00e2a0c635b515f92694be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ebb668cbba5d9268f79cd261e4d6ba"><td class="memItemLeft" align="right" valign="top"><a id="a11ebb668cbba5d9268f79cd261e4d6ba"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>isUnitOpen</b> (const Bounds &amp;upperBound, const Bounds &amp;lowerBound)</td></tr>
<tr class="separator:a11ebb668cbba5d9268f79cd261e4d6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d9aa067144f0bc261617625ffbfa82"><td class="memItemLeft" align="right" valign="top"><a id="ae5d9aa067144f0bc261617625ffbfa82"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSimple</b> (const Bounds &amp;upperBound, const Bounds &amp;lowerBound)</td></tr>
<tr class="separator:ae5d9aa067144f0bc261617625ffbfa82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9906740b3c93deb349aec1a79c7f11"><td class="memItemLeft" align="right" valign="top"><a id="a2f9906740b3c93deb349aec1a79c7f11"></a>
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>print</b> (std::ostream &amp;os, const learnta::Bounds &amp;b)</td></tr>
<tr class="separator:a2f9906740b3c93deb349aec1a79c7f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbb5a0acd464700851ce7f13d2ab12d"><td class="memItemLeft" align="right" valign="top"><a id="a1cbb5a0acd464700851ce7f13d2ab12d"></a>
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>print</b> (std::ostream &amp;os, learnta::Bounds &amp;&amp;b)</td></tr>
<tr class="separator:a1cbb5a0acd464700851ce7f13d2ab12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8b5198394709772854d8aa16f7d0db"><td class="memTemplParams" colspan="2"><a id="a2c8b5198394709772854d8aa16f7d0db"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a2c8b5198394709772854d8aa16f7d0db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#a2c8b5198394709772854d8aa16f7d0db">is_ascending</a> (const std::vector&lt; T &gt; &amp;container)</td></tr>
<tr class="memdesc:a2c8b5198394709772854d8aa16f7d0db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the elements are sorted in the ascending order. <br /></td></tr>
<tr class="separator:a2c8b5198394709772854d8aa16f7d0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070572f6dc1d7336b756a93d6e65a9bc"><td class="memTemplParams" colspan="2"><a id="a070572f6dc1d7336b756a93d6e65a9bc"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a070572f6dc1d7336b756a93d6e65a9bc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#a070572f6dc1d7336b756a93d6e65a9bc">is_strict_ascending</a> (const std::vector&lt; T &gt; &amp;container)</td></tr>
<tr class="memdesc:a070572f6dc1d7336b756a93d6e65a9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the elements are sorted in the strict ascending order. <br /></td></tr>
<tr class="separator:a070572f6dc1d7336b756a93d6e65a9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161a6a5addc2ad7c846188a0a8ab1f7b"><td class="memTemplParams" colspan="2"><a id="a161a6a5addc2ad7c846188a0a8ab1f7b"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a161a6a5addc2ad7c846188a0a8ab1f7b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#a161a6a5addc2ad7c846188a0a8ab1f7b">first</a> (const std::pair&lt; T, U &gt; &amp;pair)</td></tr>
<tr class="memdesc:a161a6a5addc2ad7c846188a0a8ab1f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first element of a pair. <br /></td></tr>
<tr class="separator:a161a6a5addc2ad7c846188a0a8ab1f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7062c7bc67a3ecf57d0025798ea6e46"><td class="memTemplParams" colspan="2"><a id="ac7062c7bc67a3ecf57d0025798ea6e46"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ac7062c7bc67a3ecf57d0025798ea6e46"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#ac7062c7bc67a3ecf57d0025798ea6e46">second</a> (const std::pair&lt; T, U &gt; &amp;pair)</td></tr>
<tr class="memdesc:ac7062c7bc67a3ecf57d0025798ea6e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the second element of a pair. <br /></td></tr>
<tr class="separator:ac7062c7bc67a3ecf57d0025798ea6e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c02a37c37e30dd46516c33346fa384"><td class="memTemplParams" colspan="2"><a id="a08c02a37c37e30dd46516c33346fa384"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a08c02a37c37e30dd46516c33346fa384"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#a08c02a37c37e30dd46516c33346fa384">is_first</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a08c02a37c37e30dd46516c33346fa384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a function checking if the first element equal to the given value. <br /></td></tr>
<tr class="separator:a08c02a37c37e30dd46516c33346fa384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaade079f10f19cd7d4608ba864f1b72"><td class="memTemplParams" colspan="2"><a id="aaaade079f10f19cd7d4608ba864f1b72"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aaaade079f10f19cd7d4608ba864f1b72"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#aaaade079f10f19cd7d4608ba864f1b72">is_second</a> (const U &amp;value)</td></tr>
<tr class="memdesc:aaaade079f10f19cd7d4608ba864f1b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a function checking if the second element equal to the given value. <br /></td></tr>
<tr class="separator:aaaade079f10f19cd7d4608ba864f1b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a4587e24dcc44d5abac8310728aac1"><td class="memItemLeft" align="right" valign="top"><a id="a60a4587e24dcc44d5abac8310728aac1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>toBool</b> (<a class="el" href="namespacelearnta.html#a66b60facb93a4fb16c606afa351cc170">Order</a> odr)</td></tr>
<tr class="separator:a60a4587e24dcc44d5abac8310728aac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e0294a736ba2b795a13729b22e2c5c"><td class="memItemLeft" align="right" valign="top"><a id="aa2e0294a736ba2b795a13729b22e2c5c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>orderToInt</b> (learnta::Constraint::Order order)</td></tr>
<tr class="separator:aa2e0294a736ba2b795a13729b22e2c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91dc8c7989e76d0a03a9f33b68fb55b6"><td class="memItemLeft" align="right" valign="top"><a id="a91dc8c7989e76d0a03a9f33b68fb55b6"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>hash_value</b> (const <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> guard)</td></tr>
<tr class="separator:a91dc8c7989e76d0a03a9f33b68fb55b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d232a534994dd90e188c8f616829898"><td class="memItemLeft" align="right" valign="top"><a id="a1d232a534994dd90e188c8f616829898"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>isWeaker</b> (const std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt; &amp;left, const std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt; &amp;right)</td></tr>
<tr class="separator:a1d232a534994dd90e188c8f616829898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edd97d42c48adb3afb361854f2fe14e"><td class="memItemLeft" align="right" valign="top"><a id="a0edd97d42c48adb3afb361854f2fe14e"></a>
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const Constraint::Order &amp;odr)</td></tr>
<tr class="separator:a0edd97d42c48adb3afb361854f2fe14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a02771c654999091edc744c55b7d97f"><td class="memItemLeft" align="right" valign="top"><a id="a7a02771c654999091edc744c55b7d97f"></a>
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &amp;p)</td></tr>
<tr class="separator:a7a02771c654999091edc744c55b7d97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b93a397db0905ecbd5f2cd2d930b28"><td class="memItemLeft" align="right" valign="top"><a id="ab9b93a397db0905ecbd5f2cd2d930b28"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#ab9b93a397db0905ecbd5f2cd2d930b28">widen</a> (std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt; &amp;guard)</td></tr>
<tr class="memdesc:ab9b93a397db0905ecbd5f2cd2d930b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove any inequality x &gt; c or x &gt;= c <br /></td></tr>
<tr class="separator:ab9b93a397db0905ecbd5f2cd2d930b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782b534b11078f5084529193670a6856"><td class="memItemLeft" align="right" valign="top"><a id="a782b534b11078f5084529193670a6856"></a>
std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>negateAll</b> (const std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt; &amp;constraints)</td></tr>
<tr class="separator:a782b534b11078f5084529193670a6856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521ca5258dd71f24f600cd82ce391bcc"><td class="memItemLeft" align="right" valign="top"><a id="a521ca5258dd71f24f600cd82ce391bcc"></a>
std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>conjunction</b> (const std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt; &amp;left, const std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt; &amp;right)</td></tr>
<tr class="separator:a521ca5258dd71f24f600cd82ce391bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c90227d1d9c8ffb49f3fe7192ecfb0"><td class="memItemLeft" align="right" valign="top"><a id="a60c90227d1d9c8ffb49f3fe7192ecfb0"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>toBounds</b> (const std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt; &amp;constraints)</td></tr>
<tr class="separator:a60c90227d1d9c8ffb49f3fe7192ecfb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bf25c34d38dcc1804917939714a8c2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; ClockVariables &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#a15bf25c34d38dcc1804917939714a8c2">simpleVariables</a> (const std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt; &amp;constraints)</td></tr>
<tr class="memdesc:a15bf25c34d38dcc1804917939714a8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the variables that are bounded by a simple constraint, i.e., c &lt; x &lt; c + 1 or x = c.  <a href="namespacelearnta.html#a15bf25c34d38dcc1804917939714a8c2">More...</a><br /></td></tr>
<tr class="separator:a15bf25c34d38dcc1804917939714a8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb4209ff4034079098cd71feda3c0fc"><td class="memItemLeft" align="right" valign="top"><a id="a2eb4209ff4034079098cd71feda3c0fc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>satisfiable</b> (const std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt; &amp;constraints)</td></tr>
<tr class="separator:a2eb4209ff4034079098cd71feda3c0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548e61dba037c65dd513a91f48ab98c9"><td class="memItemLeft" align="right" valign="top"><a id="a548e61dba037c65dd513a91f48ab98c9"></a>
std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>simplify</b> (const std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt; &amp;constraints)</td></tr>
<tr class="separator:a548e61dba037c65dd513a91f48ab98c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5559b778f68aa015c7ade9a9e09e29"><td class="memItemLeft" align="right" valign="top"><a id="a0e5559b778f68aa015c7ade9a9e09e29"></a>
Bounds&#160;</td><td class="memItemRight" valign="bottom"><b>lowerBoundDurationToSatisfy</b> (const std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt; &amp;guard, const std::vector&lt; double &gt; &amp;valuation)</td></tr>
<tr class="separator:a0e5559b778f68aa015c7ade9a9e09e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1280d4399e97249fbf92028fdf17e96b"><td class="memItemLeft" align="right" valign="top"><a id="a1280d4399e97249fbf92028fdf17e96b"></a>
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt; &amp;guards)</td></tr>
<tr class="separator:a1280d4399e97249fbf92028fdf17e96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b8a8a581873e747c11e13cb3a8757f"><td class="memItemLeft" align="right" valign="top"><a id="a79b8a8a581873e747c11e13cb3a8757f"></a>
std::vector&lt; std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>negate</b> (const std::vector&lt; std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt;&gt; &amp;dnfConstraints)</td></tr>
<tr class="separator:a79b8a8a581873e747c11e13cb3a8757f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1917ad032ef160dda054d866e2f6db"><td class="memItemLeft" align="right" valign="top"><a id="aee1917ad032ef160dda054d866e2f6db"></a>
static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#aee1917ad032ef160dda054d866e2f6db">unionHull</a> (const std::vector&lt; std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt;&gt; &amp;guards)</td></tr>
<tr class="memdesc:aee1917ad032ef160dda054d866e2f6db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the strongest guard that is weaker than all of the given guards. <br /></td></tr>
<tr class="separator:aee1917ad032ef160dda054d866e2f6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fe7553d0d7aa9cfce027b378b8c089"><td class="memItemLeft" align="right" valign="top"><a id="a09fe7553d0d7aa9cfce027b378b8c089"></a>
static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#a09fe7553d0d7aa9cfce027b378b8c089">unionHull</a> (const std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt; &amp;left, const std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt; &amp;right)</td></tr>
<tr class="memdesc:a09fe7553d0d7aa9cfce027b378b8c089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the strongest guard that is weaker than the given guards. <br /></td></tr>
<tr class="separator:a09fe7553d0d7aa9cfce027b378b8c089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97df965cd7b23cfb8bed0e8d19e4b0a7"><td class="memItemLeft" align="right" valign="top"><a id="a97df965cd7b23cfb8bed0e8d19e4b0a7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addUpperBound</b> (std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt; &amp;guard)</td></tr>
<tr class="separator:a97df965cd7b23cfb8bed0e8d19e4b0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1a8e01aec43ec4ac1afcc95e438852"><td class="memItemLeft" align="right" valign="top"><a id="a1f1a8e01aec43ec4ac1afcc95e438852"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#a1f1a8e01aec43ec4ac1afcc95e438852">adjacent</a> (const std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt; &amp;left, const std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt; &amp;right)</td></tr>
<tr class="memdesc:a1f1a8e01aec43ec4ac1afcc95e438852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two guards are adjacent. <br /></td></tr>
<tr class="separator:a1f1a8e01aec43ec4ac1afcc95e438852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935cc0fbf3d337bfa6fb280c517e6f67"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classlearnta_1_1TimedWord.html">TimedWord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#a935cc0fbf3d337bfa6fb280c517e6f67">analyzeCEX</a> (const <a class="el" href="classlearnta_1_1TimedWord.html">TimedWord</a> &amp;word, <a class="el" href="classlearnta_1_1MembershipOracle.html">MembershipOracle</a> &amp;oracle, const <a class="el" href="classlearnta_1_1RecognizableLanguage.html">RecognizableLanguage</a> &amp;hypothesis, const std::vector&lt; <a class="el" href="classlearnta_1_1BackwardRegionalElementaryLanguage.html">BackwardRegionalElementaryLanguage</a> &gt; &amp;currentSuffixes={})</td></tr>
<tr class="memdesc:a935cc0fbf3d337bfa6fb280c517e6f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rivest-Schapire-style counterexample analysis.  <a href="namespacelearnta.html#a935cc0fbf3d337bfa6fb280c517e6f67">More...</a><br /></td></tr>
<tr class="separator:a935cc0fbf3d337bfa6fb280c517e6f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389e4e2ba1b850c46d07a874d0331b0d"><td class="memItemLeft" align="right" valign="top"><a id="a389e4e2ba1b850c46d07a874d0331b0d"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classlearnta_1_1ElementaryLanguage.html">ElementaryLanguage</a> &amp;language)</td></tr>
<tr class="separator:a389e4e2ba1b850c46d07a874d0331b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d47ed85625a53c11e6eabca41c5b01e"><td class="memItemLeft" align="right" valign="top"><a id="a2d47ed85625a53c11e6eabca41c5b01e"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>hash_value</b> (<a class="el" href="classlearnta_1_1ElementaryLanguage.html">learnta::ElementaryLanguage</a> const &amp;lang)</td></tr>
<tr class="separator:a2d47ed85625a53c11e6eabca41c5b01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09b0ca2ddff9426799262001f300cce"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#ab09b0ca2ddff9426799262001f300cce">equivalence</a> (const <a class="el" href="classlearnta_1_1ElementaryLanguage.html">ElementaryLanguage</a> &amp;left, const std::vector&lt; <a class="el" href="classlearnta_1_1TimedConditionSet.html">TimedConditionSet</a> &gt; &amp;leftRow, const <a class="el" href="classlearnta_1_1ElementaryLanguage.html">ElementaryLanguage</a> &amp;right, const std::vector&lt; <a class="el" href="classlearnta_1_1TimedConditionSet.html">TimedConditionSet</a> &gt; &amp;rightRow, const std::vector&lt; <a class="el" href="classlearnta_1_1BackwardRegionalElementaryLanguage.html">BackwardRegionalElementaryLanguage</a> &gt; &amp;suffixes, const <a class="el" href="classlearnta_1_1RenamingRelation.html">RenamingRelation</a> &amp;renaming)</td></tr>
<tr class="memdesc:ab09b0ca2ddff9426799262001f300cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if two elementary languages are equivalent.  <a href="namespacelearnta.html#ab09b0ca2ddff9426799262001f300cce">More...</a><br /></td></tr>
<tr class="separator:ab09b0ca2ddff9426799262001f300cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d2824c733f8807a4f4be841fa7f93d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#a71d2824c733f8807a4f4be841fa7f93d">equivalence</a> (<a class="el" href="classlearnta_1_1JuxtaposedZone.html">JuxtaposedZone</a> leftRightJuxtaposition, const std::vector&lt; <a class="el" href="classlearnta_1_1JuxtaposedZoneSet.html">JuxtaposedZoneSet</a> &gt; &amp;leftJuxtapositions, const std::vector&lt; <a class="el" href="classlearnta_1_1JuxtaposedZoneSet.html">JuxtaposedZoneSet</a> &gt; &amp;rightJuxtapositions, const <a class="el" href="classlearnta_1_1RenamingRelation.html">RenamingRelation</a> &amp;renaming)</td></tr>
<tr class="memdesc:a71d2824c733f8807a4f4be841fa7f93d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if two elementary languages are equivalent.  <a href="namespacelearnta.html#a71d2824c733f8807a4f4be841fa7f93d">More...</a><br /></td></tr>
<tr class="separator:a71d2824c733f8807a4f4be841fa7f93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8700a05050b1572e35f7ce894fd846"><td class="memItemLeft" align="right" valign="top">static RenamingGraph&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#a4f8700a05050b1572e35f7ce894fd846">toGraph</a> (const <a class="el" href="classlearnta_1_1TimedCondition.html">TimedCondition</a> &amp;left, const <a class="el" href="classlearnta_1_1TimedCondition.html">TimedCondition</a> &amp;right)</td></tr>
<tr class="memdesc:a4f8700a05050b1572e35f7ce894fd846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the intermediate bipartite graph for candidate generation from timed conditions.  <a href="namespacelearnta.html#a4f8700a05050b1572e35f7ce894fd846">More...</a><br /></td></tr>
<tr class="separator:a4f8700a05050b1572e35f7ce894fd846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82f9ef0e38a78fdbae4d63cc9264cf0"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="classlearnta_1_1RenamingRelation.html">RenamingRelation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#ae82f9ef0e38a78fdbae4d63cc9264cf0">generateDeterministicCandidates</a> (const <a class="el" href="classlearnta_1_1TimedCondition.html">TimedCondition</a> &amp;left, const <a class="el" href="classlearnta_1_1TimedCondition.html">TimedCondition</a> &amp;right, const RenamingGraph &amp;graph)</td></tr>
<tr class="memdesc:ae82f9ef0e38a78fdbae4d63cc9264cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct candidate renaming relations that are deterministic, i.e., the corresponding reset only makes precise clocks.  <a href="namespacelearnta.html#ae82f9ef0e38a78fdbae4d63cc9264cf0">More...</a><br /></td></tr>
<tr class="separator:ae82f9ef0e38a78fdbae4d63cc9264cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ddb87e0af8096cd92ab7500752b166"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classlearnta_1_1RenamingRelation.html">RenamingRelation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#af9ddb87e0af8096cd92ab7500752b166">findDeterministicEquivalentRenaming</a> (const <a class="el" href="classlearnta_1_1ElementaryLanguage.html">ElementaryLanguage</a> &amp;left, const std::vector&lt; <a class="el" href="classlearnta_1_1TimedConditionSet.html">TimedConditionSet</a> &gt; &amp;leftRow, const <a class="el" href="classlearnta_1_1ElementaryLanguage.html">ElementaryLanguage</a> &amp;right, const std::vector&lt; <a class="el" href="classlearnta_1_1TimedConditionSet.html">TimedConditionSet</a> &gt; &amp;rightRow, const std::vector&lt; <a class="el" href="classlearnta_1_1BackwardRegionalElementaryLanguage.html">BackwardRegionalElementaryLanguage</a> &gt; &amp;suffixes)</td></tr>
<tr class="memdesc:af9ddb87e0af8096cd92ab7500752b166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a renaming constraint if two elementary languages are equivalent.  <a href="namespacelearnta.html#af9ddb87e0af8096cd92ab7500752b166">More...</a><br /></td></tr>
<tr class="separator:af9ddb87e0af8096cd92ab7500752b166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd9dca7ad90a3b325113ed29e2d992a"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classlearnta_1_1RenamingRelation.html">RenamingRelation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#a9fd9dca7ad90a3b325113ed29e2d992a">findEquivalentRenaming</a> (const <a class="el" href="classlearnta_1_1ElementaryLanguage.html">ElementaryLanguage</a> &amp;left, const std::vector&lt; <a class="el" href="classlearnta_1_1TimedConditionSet.html">TimedConditionSet</a> &gt; &amp;leftRow, const <a class="el" href="classlearnta_1_1ElementaryLanguage.html">ElementaryLanguage</a> &amp;right, const std::vector&lt; <a class="el" href="classlearnta_1_1TimedConditionSet.html">TimedConditionSet</a> &gt; &amp;rightRow, const std::vector&lt; <a class="el" href="classlearnta_1_1BackwardRegionalElementaryLanguage.html">BackwardRegionalElementaryLanguage</a> &gt; &amp;suffixes)</td></tr>
<tr class="memdesc:a9fd9dca7ad90a3b325113ed29e2d992a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a renaming constraint if two elementary languages are equivalent.  <a href="namespacelearnta.html#a9fd9dca7ad90a3b325113ed29e2d992a">More...</a><br /></td></tr>
<tr class="separator:a9fd9dca7ad90a3b325113ed29e2d992a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6380dc32c5cdbdc87442dabfb3b7c1"><td class="memItemLeft" align="right" valign="top"><a id="add6380dc32c5cdbdc87442dabfb3b7c1"></a>
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classlearnta_1_1ForwardRegionalElementaryLanguage.html">learnta::ForwardRegionalElementaryLanguage</a> &amp;lang)</td></tr>
<tr class="separator:add6380dc32c5cdbdc87442dabfb3b7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af974786785ac0b34ae6130b8193af026"><td class="memItemLeft" align="right" valign="top"><a id="af974786785ac0b34ae6130b8193af026"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>hash_value</b> (<a class="el" href="classlearnta_1_1ForwardRegionalElementaryLanguage.html">learnta::ForwardRegionalElementaryLanguage</a> const &amp;lang)</td></tr>
<tr class="separator:af974786785ac0b34ae6130b8193af026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac473b9a27de386897c4023635963c289"><td class="memItemLeft" align="right" valign="top"><a id="ac473b9a27de386897c4023635963c289"></a>
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classlearnta_1_1FractionalOrder.html">learnta::FractionalOrder</a> &amp;order)</td></tr>
<tr class="separator:ac473b9a27de386897c4023635963c289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c4a4326758ce9d6735eb71be054346"><td class="memItemLeft" align="right" valign="top"><a id="a52c4a4326758ce9d6735eb71be054346"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>hash_value</b> (<a class="el" href="classlearnta_1_1FractionalOrder.html">learnta::FractionalOrder</a> const &amp;order)</td></tr>
<tr class="separator:a52c4a4326758ce9d6735eb71be054346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e061a8ca57649a0c33c39f64b256dfd"><td class="memItemLeft" align="right" valign="top"><a id="a6e061a8ca57649a0c33c39f64b256dfd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>intersectionTA</b> (const <a class="el" href="structlearnta_1_1TimedAutomaton.html">TimedAutomaton</a> &amp;in1, const <a class="el" href="structlearnta_1_1TimedAutomaton.html">TimedAutomaton</a> &amp;in2, <a class="el" href="structlearnta_1_1TimedAutomaton.html">TimedAutomaton</a> &amp;out, boost::unordered_map&lt; std::pair&lt; <a class="el" href="structlearnta_1_1TAState.html">TAState</a> *, <a class="el" href="structlearnta_1_1TAState.html">TAState</a> * &gt;, std::shared_ptr&lt; <a class="el" href="structlearnta_1_1TAState.html">TAState</a> &gt;&gt; &amp;toIState)</td></tr>
<tr class="separator:a6e061a8ca57649a0c33c39f64b256dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89724a11197aa5d60ea41c9cf43f9cc"><td class="memItemLeft" align="right" valign="top"><a id="ad89724a11197aa5d60ea41c9cf43f9cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateInitAccepting</b> (const <a class="el" href="structlearnta_1_1TimedAutomaton.html">TimedAutomaton</a> &amp;in1, const <a class="el" href="structlearnta_1_1TimedAutomaton.html">TimedAutomaton</a> &amp;in2, <a class="el" href="structlearnta_1_1TimedAutomaton.html">TimedAutomaton</a> &amp;out, boost::unordered_map&lt; std::pair&lt; <a class="el" href="structlearnta_1_1TAState.html">TAState</a> *, <a class="el" href="structlearnta_1_1TAState.html">TAState</a> * &gt;, std::shared_ptr&lt; <a class="el" href="structlearnta_1_1TAState.html">TAState</a> &gt;&gt; toIState)</td></tr>
<tr class="separator:ad89724a11197aa5d60ea41c9cf43f9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad3639758e1b80563eeb0e7addcd982"><td class="memItemLeft" align="right" valign="top"><a id="a0ad3639758e1b80563eeb0e7addcd982"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>intersectionSignalTA</b> (const <a class="el" href="structlearnta_1_1TimedAutomaton.html">TimedAutomaton</a> &amp;in1, const <a class="el" href="structlearnta_1_1TimedAutomaton.html">TimedAutomaton</a> &amp;in2, <a class="el" href="structlearnta_1_1TimedAutomaton.html">TimedAutomaton</a> &amp;out)</td></tr>
<tr class="separator:a0ad3639758e1b80563eeb0e7addcd982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9379580ec196e3098a556b345c4529b"><td class="memItemLeft" align="right" valign="top"><a id="ae9379580ec196e3098a556b345c4529b"></a>
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classlearnta_1_1NeighborConditions.html">learnta::NeighborConditions</a> &amp;conditions)</td></tr>
<tr class="separator:ae9379580ec196e3098a556b345c4529b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0924d8e41fc00ae31cd5f4b6137d79b1"><td class="memItemLeft" align="right" valign="top"><a id="a0924d8e41fc00ae31cd5f4b6137d79b1"></a>
static std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>hash_value</b> (const <a class="el" href="classlearnta_1_1NeighborConditions.html">NeighborConditions</a> &amp;conditions)</td></tr>
<tr class="separator:a0924d8e41fc00ae31cd5f4b6137d79b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cfe70fb0744c04ea6dcfb66fe700f9"><td class="memItemLeft" align="right" valign="top"><a id="aa2cfe70fb0744c04ea6dcfb66fe700f9"></a>
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#aa2cfe70fb0744c04ea6dcfb66fe700f9">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classlearnta_1_1SymbolicRun.html">learnta::SymbolicRun</a> &amp;run)</td></tr>
<tr class="memdesc:aa2cfe70fb0744c04ea6dcfb66fe700f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the symbolic run. <br /></td></tr>
<tr class="separator:aa2cfe70fb0744c04ea6dcfb66fe700f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab014254bdca4f68274d419145bb1ea6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#ab014254bdca4f68274d419145bb1ea6d">ta2za</a> (const <a class="el" href="structlearnta_1_1TimedAutomaton.html">TimedAutomaton</a> &amp;TA, <a class="el" href="structlearnta_1_1ZoneAutomaton.html">ZoneAutomaton</a> &amp;ZA, bool quickReturn=true)</td></tr>
<tr class="memdesc:ab014254bdca4f68274d419145bb1ea6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a zone automaton from a timed automaton.  <a href="namespacelearnta.html#ab014254bdca4f68274d419145bb1ea6d">More...</a><br /></td></tr>
<tr class="separator:ab014254bdca4f68274d419145bb1ea6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68a6a2e7bde87a6f01e6a3a26142305"><td class="memItemLeft" align="right" valign="top"><a id="ad68a6a2e7bde87a6f01e6a3a26142305"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>hash_value</b> (const <a class="el" href="structlearnta_1_1TATransition.html">TATransition</a> &amp;transition)</td></tr>
<tr class="separator:ad68a6a2e7bde87a6f01e6a3a26142305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78514fbefc7f979a6122fd32e9bc5fea"><td class="memItemLeft" align="right" valign="top"><a id="a78514fbefc7f979a6122fd32e9bc5fea"></a>
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="structlearnta_1_1TimedAutomaton.html">TimedAutomaton</a> &amp;TA)</td></tr>
<tr class="separator:a78514fbefc7f979a6122fd32e9bc5fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f881e12b532170884138cdb291bb9f4"><td class="memItemLeft" align="right" valign="top"><a id="a5f881e12b532170884138cdb291bb9f4"></a>
static std::unordered_map&lt; ClockVariables, std::variant&lt; double, ClockVariables &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>asMap</b> (const TATransition::Resets &amp;resets)</td></tr>
<tr class="separator:a5f881e12b532170884138cdb291bb9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762e50140f2894af8fe4e02dbe55899f"><td class="memItemLeft" align="right" valign="top"><a id="a762e50140f2894af8fe4e02dbe55899f"></a>
static TATransition::Resets&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#a762e50140f2894af8fe4e02dbe55899f">composition</a> (const TATransition::Resets &amp;left, const TATransition::Resets &amp;right)</td></tr>
<tr class="memdesc:a762e50140f2894af8fe4e02dbe55899f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the composition ( \(left \circ right\)) of the resets. <br /></td></tr>
<tr class="separator:a762e50140f2894af8fe4e02dbe55899f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c20143422c14b2bc4b5d77f83266445"><td class="memItemLeft" align="right" valign="top"><a id="a1c20143422c14b2bc4b5d77f83266445"></a>
static TATransition::Resets&#160;</td><td class="memItemRight" valign="bottom"><b>addDefault</b> (const TATransition::Resets &amp;original, const TATransition::Resets &amp;defaultReset)</td></tr>
<tr class="separator:a1c20143422c14b2bc4b5d77f83266445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e377467848ac073f20e1e8361d3339f"><td class="memItemLeft" align="right" valign="top"><a id="a5e377467848ac073f20e1e8361d3339f"></a>
static TATransition::Resets&#160;</td><td class="memItemRight" valign="bottom"><b>clean</b> (const TATransition::Resets &amp;resets)</td></tr>
<tr class="separator:a5e377467848ac073f20e1e8361d3339f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7e905c5bbcf0e4ab15ca12a74a2031"><td class="memItemLeft" align="right" valign="top"><a id="a7f7e905c5bbcf0e4ab15ca12a74a2031"></a>
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>print</b> (std::ostream &amp;os, const <a class="el" href="classlearnta_1_1TimedCondition.html">learnta::TimedCondition</a> &amp;cond)</td></tr>
<tr class="separator:a7f7e905c5bbcf0e4ab15ca12a74a2031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c668c481425339580a90d68bed90e79"><td class="memItemLeft" align="right" valign="top"><a id="a9c668c481425339580a90d68bed90e79"></a>
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classlearnta_1_1TimedCondition.html">learnta::TimedCondition</a> &amp;b)</td></tr>
<tr class="separator:a9c668c481425339580a90d68bed90e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafd2230f83e6721870bdf4779bd431a"><td class="memItemLeft" align="right" valign="top"><a id="afafd2230f83e6721870bdf4779bd431a"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>hash_value</b> (<a class="el" href="classlearnta_1_1TimedCondition.html">learnta::TimedCondition</a> const &amp;timedCondition)</td></tr>
<tr class="separator:afafd2230f83e6721870bdf4779bd431a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab90312ecba3cedb849e26c318b4b68"><td class="memItemLeft" align="right" valign="top"><a id="a9ab90312ecba3cedb849e26c318b4b68"></a>
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>print</b> (std::ostream &amp;os, const <a class="el" href="classlearnta_1_1TimedWord.html">learnta::TimedWord</a> &amp;word)</td></tr>
<tr class="separator:a9ab90312ecba3cedb849e26c318b4b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb05b7bc36a1b2cf420084e8c89a9a49"><td class="memItemLeft" align="right" valign="top"><a id="afb05b7bc36a1b2cf420084e8c89a9a49"></a>
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classlearnta_1_1TimedWord.html">learnta::TimedWord</a> &amp;word)</td></tr>
<tr class="separator:afb05b7bc36a1b2cf420084e8c89a9a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b4a87515c72da5cedd84209a765e97"><td class="memItemLeft" align="right" valign="top"><a id="a54b4a87515c72da5cedd84209a765e97"></a>
static std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>hash_value</b> (const <a class="el" href="classlearnta_1_1TimedWord.html">TimedWord</a> &amp;word)</td></tr>
<tr class="separator:a54b4a87515c72da5cedd84209a765e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d761b17021123d7c2b441d75b605815"><td class="memItemLeft" align="right" valign="top"><a id="a6d761b17021123d7c2b441d75b605815"></a>
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#a6d761b17021123d7c2b441d75b605815">print</a> (std::ostream &amp;os, const <a class="el" href="structlearnta_1_1Zone.html">learnta::Zone</a> &amp;zone)</td></tr>
<tr class="memdesc:a6d761b17021123d7c2b441d75b605815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the zone. <br /></td></tr>
<tr class="separator:a6d761b17021123d7c2b441d75b605815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee40ac5b097d4249c2d53ca6344774a"><td class="memItemLeft" align="right" valign="top"><a id="a6ee40ac5b097d4249c2d53ca6344774a"></a>
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="structlearnta_1_1Zone.html">learnta::Zone</a> &amp;zone)</td></tr>
<tr class="separator:a6ee40ac5b097d4249c2d53ca6344774a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fca5a66505f9c3ea6896944ae7b0d2"><td class="memItemLeft" align="right" valign="top"><a id="ac5fca5a66505f9c3ea6896944ae7b0d2"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>hash_value</b> (<a class="el" href="structlearnta_1_1Zone.html">learnta::Zone</a> const &amp;zone)</td></tr>
<tr class="separator:ac5fca5a66505f9c3ea6896944ae7b0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b54bceae793db4d26193a3e1f64732f"><td class="memItemLeft" align="right" valign="top"><a id="a2b54bceae793db4d26193a3e1f64732f"></a>
std::vector&lt; ClockVariables &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#a2b54bceae793db4d26193a3e1f64732f">impreciseClocksAfterTransition</a> (const <a class="el" href="structlearnta_1_1TATransition.html">TATransition</a> &amp;transition)</td></tr>
<tr class="memdesc:a2b54bceae793db4d26193a3e1f64732f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the imprecise clocks after transition. <br /></td></tr>
<tr class="separator:a2b54bceae793db4d26193a3e1f64732f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8db0fea7762dbefadb75b553123a83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlearnta_1_1TATransition.html">TATransition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelearnta.html#a1a8db0fea7762dbefadb75b553123a83">mergeTransitions</a> (const <a class="el" href="structlearnta_1_1TATransition.html">TATransition</a> &amp;left, const <a class="el" href="structlearnta_1_1TATransition.html">TATransition</a> &amp;right)</td></tr>
<tr class="memdesc:a1a8db0fea7762dbefadb75b553123a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two TATransitions.  <a href="namespacelearnta.html#a1a8db0fea7762dbefadb75b553123a83">More...</a><br /></td></tr>
<tr class="separator:a1a8db0fea7762dbefadb75b553123a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:afbf5dd4f979da8908c64d27d471e83e6"><td class="memItemLeft" align="right" valign="top"><a id="afbf5dd4f979da8908c64d27d471e83e6"></a>
const Alphabet&#160;</td><td class="memItemRight" valign="bottom"><b>UNOBSERVABLE</b> = 0</td></tr>
<tr class="separator:afbf5dd4f979da8908c64d27d471e83e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6dfb39e2c47d45bc35ca548bbcd1e7c"><td class="memItemLeft" align="right" valign="top"><a id="af6dfb39e2c47d45bc35ca548bbcd1e7c"></a>
const auto&#160;</td><td class="memItemRight" valign="bottom"><b>UNOBSERVABLE_STRING</b> = &quot;&quot;</td></tr>
<tr class="separator:af6dfb39e2c47d45bc35ca548bbcd1e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022/09/09.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022/09/16.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022/03/07.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022/03/06.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2023/01/20.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022/11/30.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022/03/04.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022/03/31.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022/03/15.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022/09/20.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022/03/27.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022/03/05.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2023/01/10.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022/09/14.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022/03/13.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022/03/20.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022/11/29.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022/12/29.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022/11/03.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022/03/21.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022/11/01.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022/12/23.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022/09/04.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Masaki Waga </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022/04/02. </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a935cc0fbf3d337bfa6fb280c517e6f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935cc0fbf3d337bfa6fb280c517e6f67">&#9670;&nbsp;</a></span>analyzeCEX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::optional&lt;<a class="el" href="classlearnta_1_1TimedWord.html">TimedWord</a>&gt; learnta::analyzeCEX </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlearnta_1_1TimedWord.html">TimedWord</a> &amp;&#160;</td>
          <td class="paramname"><em>word</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlearnta_1_1MembershipOracle.html">MembershipOracle</a> &amp;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlearnta_1_1RecognizableLanguage.html">RecognizableLanguage</a> &amp;&#160;</td>
          <td class="paramname"><em>hypothesis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlearnta_1_1BackwardRegionalElementaryLanguage.html">BackwardRegionalElementaryLanguage</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>currentSuffixes</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rivest-Schapire-style counterexample analysis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">word</td><td>The analyzed counterexample </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oracle</td><td>The membership oracle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hypothesis</td><td>The hypothesis recognizable language</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>word is a counterexample. Namely, we should have oracle-&gt;answerQuery(word) != hypothesis.contains(word) </dd></dl>

</div>
</div>
<a id="ab09b0ca2ddff9426799262001f300cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09b0ca2ddff9426799262001f300cce">&#9670;&nbsp;</a></span>equivalence() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool learnta::equivalence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlearnta_1_1ElementaryLanguage.html">ElementaryLanguage</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlearnta_1_1TimedConditionSet.html">TimedConditionSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>leftRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlearnta_1_1ElementaryLanguage.html">ElementaryLanguage</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlearnta_1_1TimedConditionSet.html">TimedConditionSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rightRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlearnta_1_1BackwardRegionalElementaryLanguage.html">BackwardRegionalElementaryLanguage</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>suffixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlearnta_1_1RenamingRelation.html">RenamingRelation</a> &amp;&#160;</td>
          <td class="paramname"><em>renaming</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return if two elementary languages are equivalent. </p>
<dl class="section pre"><dt>Precondition</dt><dd>leftRow.size() == rightRow.size() == suffixes.size() </dd></dl>

</div>
</div>
<a id="a71d2824c733f8807a4f4be841fa7f93d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d2824c733f8807a4f4be841fa7f93d">&#9670;&nbsp;</a></span>equivalence() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool learnta::equivalence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlearnta_1_1JuxtaposedZone.html">JuxtaposedZone</a>&#160;</td>
          <td class="paramname"><em>leftRightJuxtaposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlearnta_1_1JuxtaposedZoneSet.html">JuxtaposedZoneSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>leftJuxtapositions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlearnta_1_1JuxtaposedZoneSet.html">JuxtaposedZoneSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rightJuxtapositions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlearnta_1_1RenamingRelation.html">RenamingRelation</a> &amp;&#160;</td>
          <td class="paramname"><em>renaming</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return if two elementary languages are equivalent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leftRightJuxtaposition</td><td>juxtaposition of left and right prefixes </td></tr>
    <tr><td class="paramname">leftJuxtapositions</td><td>list of juxtaposition of mem(left + suffix) and (right + suffix) </td></tr>
    <tr><td class="paramname">rightJuxtapositions</td><td>list of juxtaposition of (left + suffix) and mem(right + suffix)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>leftJuxtapositions.size() == rightJuxtapositions.size() </dd></dl>

</div>
</div>
<a id="af9ddb87e0af8096cd92ab7500752b166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ddb87e0af8096cd92ab7500752b166">&#9670;&nbsp;</a></span>findDeterministicEquivalentRenaming()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::optional&lt;<a class="el" href="classlearnta_1_1RenamingRelation.html">RenamingRelation</a>&gt; learnta::findDeterministicEquivalentRenaming </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlearnta_1_1ElementaryLanguage.html">ElementaryLanguage</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlearnta_1_1TimedConditionSet.html">TimedConditionSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>leftRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlearnta_1_1ElementaryLanguage.html">ElementaryLanguage</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlearnta_1_1TimedConditionSet.html">TimedConditionSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rightRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlearnta_1_1BackwardRegionalElementaryLanguage.html">BackwardRegionalElementaryLanguage</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>suffixes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a renaming constraint if two elementary languages are equivalent. </p>
<p>The outline of our construction is as follows.</p><ol type="1">
<li>We construct the bipartite graph based on the timed conditions.</li>
<li>We generate deterministic candidate renaming equations</li>
<li>We return a renaming equation witnessing the equivalence, if exists</li>
</ol>
<p>In the first part, we construct a bipartite graph \((V_1, V_2, E)\) such that:</p><ul>
<li>\(V_1\) and \(V_2\) consists of the variables in left and right, respectively, and</li>
<li>\((v_1, v_2) \in E\) if and only if \(v_1 = v_2\) does not contradict to the given constraints.</li>
</ul>
<p>We note that each disjoint part of this bipartite graph is complete.</p>
<dl class="section pre"><dt>Precondition</dt><dd>leftRow.size() == rightRow.size() == suffixes.size() </dd>
<dd>
left and right are simple </dd></dl>

</div>
</div>
<a id="a9fd9dca7ad90a3b325113ed29e2d992a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd9dca7ad90a3b325113ed29e2d992a">&#9670;&nbsp;</a></span>findEquivalentRenaming()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::optional&lt;<a class="el" href="classlearnta_1_1RenamingRelation.html">RenamingRelation</a>&gt; learnta::findEquivalentRenaming </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlearnta_1_1ElementaryLanguage.html">ElementaryLanguage</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlearnta_1_1TimedConditionSet.html">TimedConditionSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>leftRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlearnta_1_1ElementaryLanguage.html">ElementaryLanguage</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlearnta_1_1TimedConditionSet.html">TimedConditionSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rightRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlearnta_1_1BackwardRegionalElementaryLanguage.html">BackwardRegionalElementaryLanguage</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>suffixes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a renaming constraint if two elementary languages are equivalent. </p>
<p>The outline of our construction is as follows.</p><ol type="1">
<li>We construct the bipartite graph based on the timed conditions.</li>
<li>We make the set of the strictly constrained variables in the symbolic membership.</li>
<li>We generate a candidate of renaming constraints and return it if it witnesses the equivalence</li>
</ol>
<p>In the first part, we construct a bipartite graph \((V_1, V_2, E)\) such that:</p><ul>
<li>\(V_1\) and \(V_2\) consists of the variables in left and right, respectively, and</li>
<li>\((v_1, v_2) \in E\) if and only if \(v_1 = v_2\) does not contradict to the given constraints.</li>
</ul>
<p>We note that each disjoint part of this bipartite graph is complete.</p>
<p>In the second part, we list the variables strictly constrained in the symbolic membership. We do this simply by comparing the coefficients in the zone thanks to the canonicity of the zones. Since these strictly constrained variables must also be constrained by the renaming constraints, they are the candidates in the construction of the renaming constraints.</p>
<p>In the third part, we construct the renaming constraints by taking the largest or smallest edges in each disjoint part of the bipartite graph.</p>
<dl class="section pre"><dt>Precondition</dt><dd>leftRow.size() == rightRow.size() == suffixes.size() </dd>
<dd>
left and right are simple </dd></dl>

</div>
</div>
<a id="ae82f9ef0e38a78fdbae4d63cc9264cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82f9ef0e38a78fdbae4d63cc9264cf0">&#9670;&nbsp;</a></span>generateDeterministicCandidates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;<a class="el" href="classlearnta_1_1RenamingRelation.html">RenamingRelation</a>&gt; learnta::generateDeterministicCandidates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlearnta_1_1TimedCondition.html">TimedCondition</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlearnta_1_1TimedCondition.html">TimedCondition</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RenamingGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct candidate renaming relations that are deterministic, i.e., the corresponding reset only makes precise clocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The right timed condition in the renaming </td></tr>
    <tr><td class="paramname">graph</td><td>The renaming graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a8db0fea7762dbefadb75b553123a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8db0fea7762dbefadb75b553123a83">&#9670;&nbsp;</a></span>mergeTransitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlearnta_1_1TATransition.html">TATransition</a> learnta::mergeTransitions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlearnta_1_1TATransition.html">TATransition</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlearnta_1_1TATransition.html">TATransition</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge two TATransitions. </p>
<p>The construction is as follows.</p><ul>
<li>We basically use the transition with less imprecise clocks after it.</li>
<li>The target state and the reset is the ones of the above transition.</li>
<li>The guard is the union of the guards of the given transitions. </li>
</ul>

</div>
</div>
<a id="a15bf25c34d38dcc1804917939714a8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15bf25c34d38dcc1804917939714a8c2">&#9670;&nbsp;</a></span>simpleVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;ClockVariables&gt; learnta::simpleVariables </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structlearnta_1_1Constraint.html">Constraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the variables that are bounded by a simple constraint, i.e., c &lt; x &lt; c + 1 or x = c. </p>
<dl class="section return"><dt>Returns</dt><dd>list of variables with simple bounds in the ascending order </dd></dl>

</div>
</div>
<a id="ab014254bdca4f68274d419145bb1ea6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab014254bdca4f68274d419145bb1ea6d">&#9670;&nbsp;</a></span>ta2za()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void learnta::ta2za </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlearnta_1_1TimedAutomaton.html">TimedAutomaton</a> &amp;&#160;</td>
          <td class="paramname"><em>TA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlearnta_1_1ZoneAutomaton.html">ZoneAutomaton</a> &amp;&#160;</td>
          <td class="paramname"><em>ZA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>quickReturn</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a zone automaton from a timed automaton. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NVar</td><td>the number of variable in TA</td></tr>
  </table>
  </dd>
</dl>
<p>TA to ZA adds states with BFS. Initial configuration is the initial states of ZA. The ZA contain only the states reachable from initial states. </p>
<p>number of states of ZA</p>
<p>Make initial state, that is Current configuration of BFS</p>
<p>translater from <a class="el" href="structlearnta_1_1TAState.html" title="A state of timed automata.">TAState</a> and <a class="el" href="structlearnta_1_1Zone.html" title="Implementation of a zone with DBM.">Zone</a> to its corresponding state in ZA.</p>
<p>The type is like this. (<a class="el" href="structlearnta_1_1TAState.html" title="A state of timed automata.">TAState</a>,<a class="el" href="structlearnta_1_1Zone.html" title="Implementation of a zone with DBM.">Zone</a>) -&gt; <a class="el" href="structlearnta_1_1ZAState.html" title="A state of a zone automaton.">ZAState</a></p>
<p>number of states of ZA</p>
<p>Make initial state, that is Current configuration of BFS</p>
<p>translater from <a class="el" href="structlearnta_1_1TAState.html" title="A state of timed automata.">TAState</a> and <a class="el" href="structlearnta_1_1Zone.html" title="Implementation of a zone with DBM.">Zone</a> to its corresponding state in ZA.</p>
<p>The type is like this. (<a class="el" href="structlearnta_1_1TAState.html" title="A state of timed automata.">TAState</a>,<a class="el" href="structlearnta_1_1Zone.html" title="Implementation of a zone with DBM.">Zone</a>) -&gt; <a class="el" href="structlearnta_1_1ZAState.html" title="A state of a zone automaton.">ZAState</a></p>

</div>
</div>
<a id="a4f8700a05050b1572e35f7ce894fd846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8700a05050b1572e35f7ce894fd846">&#9670;&nbsp;</a></span>toGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static RenamingGraph learnta::toGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlearnta_1_1TimedCondition.html">TimedCondition</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlearnta_1_1TimedCondition.html">TimedCondition</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the intermediate bipartite graph for candidate generation from timed conditions. </p>
<p>The constructed graph has an edge between v1.at(i) and v2.at(j) if and only if left.getUpperBound(i, N - 1) == right.getUpperBound(j, M - 1)</p>
<dl class="section pre"><dt>Precondition</dt><dd>left and right are simple </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
